A Deep Analysis of Moiré Patterns: Mathematical Frameworks and Programming for Interactive Generation


Introduction to the Moiré Phenomenon


The Moiré effect is a large-scale visual phenomenon that emerges from the superposition of two or more repetitive structures.1 This interference pattern is not a physical property of any single layer but is a new, often magnified, pattern created by their interaction and perceived by an observer.3 The term itself is derived from a French word for watered silk, a fabric that exhibits a similar wavy, rippled appearance.5 For the effect to manifest, the overlaid patterns must be similar but not identical. The crucial difference can be a slight mismatch in their pitch (the distance between repeating elements), a relative rotation, or a translational displacement.1 This principle holds true whether the patterns are composed of lines, dots, circles, or more complex lattices.1
At its core, the Moiré pattern is a visual representation of a "beat" frequency, analogous to the acoustic beats heard when two sound waves of slightly different frequencies interfere.7 The high-frequency details of the individual layers are averaged by the human visual system, which instead perceives the lower-frequency interference pattern—the Moiré fringe.1 This effect can be generated physically, by overlaying transparent sheets with printed patterns, or digitally.10 In the digital realm, Moiré often appears as an unintended artifact known as aliasing, where the discrete grid of pixels on a display or camera sensor undersamples a high-frequency pattern in an image, creating a spurious low-frequency visual.9 Understanding this dual nature—as both a deliberate geometric construction and a potential digital artifact—is essential for creating a robust and versatile Moiré generation application.


A Taxonomy of 2D Moiré Patterns: From Primitives to Animations


A systematic classification of Moiré patterns provides a clear mental model of the creative possibilities and can directly inform the feature set and user interface of a generative application. The taxonomy can be structured by the geometric complexity of the foundational layers, progressing from simple one-dimensional primitives to complex animated systems.


Category I: Linear and Curvilinear Primitives


This category comprises the most fundamental building blocks of Moiré patterns, formed by the superposition of lines and circles. These simple interactions produce a surprisingly rich variety of complex emergent patterns and are the ideal starting point for any Moiré generator.


Line-on-Line (Parallel Gratings)


The foundational case involves overlaying two sets of parallel lines, or gratings. When the gratings have slightly different pitches, denoted as p and p′=p+δp, a new set of parallel Moiré fringes appears. This pattern demonstrates the core magnification principle of the Moiré effect. The spacing of these emergent fringes, d, is significantly larger than the original pitches and is given by the formula:


d=∣p−p′∣p×p′​


This equation reveals that as the difference in pitch (δp) approaches zero, the spacing of the Moiré fringes approaches infinity, making the effect extremely sensitive to small variations.1


Line-on-Line (Rotated Gratings)


When two identical gratings of pitch p are superimposed and rotated by a small angle θ relative to each other, a Moiré pattern of fringes emerges. These fringes are oriented nearly perpendicular to the original lines. The spacing, d, of these rotational Moiré fringes is determined by the pitch and the angle of rotation:


d=2sin(θ/2)p​


For small angles, this can be approximated as d≈p/θ. This interaction introduces orientation as a powerful and highly sensitive control parameter for manipulating the resulting pattern.1


Circle-on-Circle (Displaced Concentric)


Superimposing two identical sets of equispaced concentric circles, with their centers displaced by a small distance, generates striking Moiré patterns. The resulting fringes are not circles but rather families of hyperbolas or ellipses, with the centers of the original circle patterns acting as the foci of these conic sections.4 This demonstrates how overlaying simple radial patterns can lead to fundamentally different geometric forms.


Circle-on-Circle (Zone Plates)


A more advanced case involves the superposition of two Fresnel zone plates. A zone plate is a pattern of concentric circles where the radius of the n-th circle is proportional to n​, meaning their spacing decreases with distance from the center. Overlapping two such zone plates results in the formation of a new system of Moiré zone plates, whose properties (focal length and location) are determined by the parameters of the original plates.8 This illustrates a deeper principle: Moiré patterns can inherit and transform the complex properties of their constituent layers.


Mixed Primitives (Lines on Circles)


Combining different types of primitives offers another rich avenue for pattern generation. A classic example is the superposition of a set of equispaced parallel lines onto a set of equispaced concentric circles. The resulting Moiré pattern is a family of conic sections. Whether the fringes are hyperbolas, ellipses, or parabolas depends on the ratio of the line spacing to the circle spacing.14 This provides a powerful method for generating a diverse range of complex curves from the simplest geometric inputs.


Category II: 2D Lattice and Grid Superpositions


Moving beyond one-dimensional primitives, the superposition of two-dimensional lattices and grids forms the basis for many Moiré patterns observed in digital imaging, printing, and advanced materials science.


Dot Arrays and Grids


When two regular 2D grids of dots, such as square or rectangular arrays, are overlaid with a slight difference in scale or rotation, a larger-scale Moiré pattern emerges.16 This is the type of Moiré commonly seen as an artifact in digital printing when halftone screens are misaligned, or when photographing a computer monitor.1 The resulting pattern is itself a grid, but with a much larger "beat" periodicity.


Hexagonal Lattices ("Twistronics")


A scientifically and artistically significant case is the superposition of two hexagonal lattices, famously studied in the field of "twistronics" with materials like graphene.21 When two such layers are stacked with a small relative twist angle,
θ, a new, large-scale hexagonal Moiré superlattice is formed.24 The wavelength (or period) of this Moiré superlattice,
λ, is given by:


λ=2sin(θ/2)a​


where a is the lattice constant of the original hexagonal layers.22 At certain "magic angles" (e.g., approximately 1.1 degrees for graphene), this Moiré pattern dramatically alters the material's electronic properties, leading to phenomena like superconductivity.21 While the underlying physics is complex, the geometric principle provides a powerful basis for creating visually stunning and intricate patterns.


Objective Moiré Patterns


Objective Moiré is a generalized concept where the emergent pattern preserves the fundamental symmetry of the original structures but with altered parameters.26 For instance, superimposing two ring lattices (discrete points arranged on a circle) with slightly different angular spacings results in a new Moiré pattern that is also a ring lattice, but with a much smaller number of points.27 Similarly, two helical structures can be overlaid to produce a new helical Moiré pattern.27 This framework provides a robust mathematical foundation for predicting Moiré in structures beyond simple grids.


Category III: Special-Case and Animated Patterns


This category covers Moiré patterns that are often used in specific applications, such as creating illusions of motion or revealing hidden images. Their implementation typically requires more specialized algorithms.


Shape Moiré (Band Moiré)


Shape Moiré is a technique used to magnify and reveal tiny, hidden shapes embedded in a layer.1 One layer, the "base layer," contains periodically repeated shapes that have been compressed or sliced. When a second, simpler "revealing layer" (often a simple line or grid pattern) is moved over the base layer, the Moiré effect reconstructs and magnifies the hidden shapes.16 This method can be used for anti-counterfeiting on banknotes or for creating surprising visual effects where an image appears out of what looks like noise.1


Barrier-Grid Animation (Kinegrams/Scanimation)


Barrier-grid animation is a direct application of the Moiré effect to create the illusion of motion from a single static image.29 The technique involves two components:
1. A Composite Image: This image is created by interleaving slices from multiple frames of an animation sequence. For an animation with N frames, slices from frame 1 are followed by slices from frame 2, and so on, up to frame N.
2. A Barrier Grid: This is a transparent sheet (like acetate) with a pattern of opaque parallel lines printed on it. The grid is designed such that its transparent slits reveal the slices from only one frame at a time, while the opaque bars obscure the slices from the other N−1 frames.
As the user slides the barrier grid across the composite image, it sequentially reveals each frame, creating a smooth animation.29 The geometry must be precise: for an N-frame animation, the width of the opaque bars on the barrier grid must be
N−1 times the width of the transparent slits.29 This technique is a powerful example of encoding temporal information into a spatial Moiré system.
The logical progression from simple line-on-line patterns to complex kinegrams provides a natural development roadmap for a Moiré generator application. The user interface can guide the user from basic, intuitive interactions (adjusting pitch and rotation) towards more advanced, distinct modes for creating shape Moiré or barrier-grid animations.


The Language of Interference: Mathematical Frameworks for Moiré Generation


To programmatically generate Moiré patterns, it is essential to translate the visual phenomena into precise mathematical language. There are three primary frameworks for describing and computing Moiré patterns, each offering a different algorithmic strategy with unique advantages and trade-offs: the geometric/algebraic approach, the spectral (Fourier) approach, and the digital rendering (aliasing) approach.


The Geometric/Algebraic Approach: The Indicial Equation Method


The indicial equation method provides a direct and computationally efficient way to determine the geometry of Moiré fringes.14 This approach treats Moiré patterns as the locus of points where the curves of two superimposed families intersect in a specific, regular way.
The core idea is to represent each of the two initial patterns as an indexed family of curves. For a point (x,y) on the plane, the first pattern is described by an equation of the form F(x,y)=h, and the second pattern by G(x,y)=k, where h and k are integers that index the individual lines or curves in each family.14 The Moiré fringes are then defined by a new family of curves that satisfies a simple algebraic relationship between these indices, known as the
indicial equation. The most common and prominent Moiré pattern corresponds to the indicial equation:


Θ(h,k)=h−k=p


where p is an integer that indexes the resulting Moiré fringes.14 By substituting the expressions for
h and k into this equation and eliminating them, one can derive a direct algebraic equation for the Moiré pattern itself.
This method is exceptionally powerful because it bypasses the need to render the two dense, high-frequency base patterns. Instead, it allows for the direct plotting of the low-frequency Moiré fringes, resulting in clean, resolution-independent vector output. This is ideal for a performant web application. The following table serves as a practical guide, translating pairs of geometric primitives into the explicit equations of the resulting Moiré patterns, based on the indicial method.
Layer 1 Primitives (Eq: F(x,y)=h)
	Layer 2 Primitives (Eq: G(x,y)=k)
	Indicial Equation
	Resulting Moiré Pattern Equation
	Source(s)
	Parallel Lines: x=ah
	Rotated Lines: xcosθ−ysinθ=bk
	h−k=p
	x(a1​−bcosθ​)+ybsinθ​=p (A new set of rotated lines)
	14
	Concentric Circles: x2+y2=(ha)2
	Parallel Lines: x=bk
	h−k=±p
	(b2−a2)x2±2a2bpx+b2y2=a2b2p2 (Hyperbolas, Ellipses, or Parabolas)
	14
	Concentric Circles: x2+y2=(ha)2
	Concentric Circles: x2+y2=(kb)2
	h−rk=p
	x2+y2=(b−rapab​)2 (A new set of concentric circles)
	14
	Displaced Circles: (x−s)2+y2=h/π
	Displaced Circles: (x+s)2+y2=k/π
	h−k=p
	x=4πsp​ (Parallel vertical lines)
	14
	Radial Lines: arctan(y/x)=ha
	Radial Lines: arctan(y/x)=kb
	h−k=p
	arctan(y/x)=b−apab​ (A new set of radial lines)
	14
	

The Spectral Approach: Fourier Analysis


The Fourier approach provides a powerful analytical framework for understanding why Moiré patterns form and for predicting their properties. This method is rooted in the principle that any periodic function, such as the transparency of a grating, can be represented as a sum of sinusoidal waves (a Fourier series).8
When two patterns are superimposed, their transparency functions, g1​(x,y) and g2​(x,y), are multiplied to get the resulting transparency, h(x,y)=g1​(x,y)⋅g2​(x,y).19 According to the convolution theorem of Fourier analysis, this multiplication in the spatial domain is equivalent to a convolution in the frequency domain.19 If
R1​(u,v) and R2​(u,v) are the Fourier transforms of the two patterns, the Fourier transform of the resulting pattern, R(u,v), is:


R(u,v)=R1​(u,v)∗∗R2​(u,v)


where ∗∗ denotes the 2D convolution operation.
The key insight is that this convolution creates new frequency components that were not present in the original patterns. Each periodic pattern can be represented in the frequency domain by a set of points, or impulses. The Moiré pattern corresponds to the new, low-frequency impulses generated by the convolution. These low-frequency components are the "beat" frequencies and arise from the difference between the frequency vectors of the original patterns.7
If the two base gratings are represented by frequency vectors f1​​ and f2​​ (where the vector's direction is perpendicular to the grating lines and its magnitude is the spatial frequency), the most prominent Moiré fringe will have a frequency vector fm​​ given by the vector difference:


fm​​=f1​​−f2​​


The spacing of the Moiré fringe is 1/∣fm​​∣, and its orientation is perpendicular to the vector fm​​.7 This vectorial approach is elegant and predictive. It also explains why superimposing three or more gratings provides greater flexibility; by arranging three frequency vectors
f1​​, f2​​, and f3​​ such that their sum approaches zero (e.g., f1​​+f2​​−f3​​≈0), one can generate low-frequency Moiré patterns from gratings with very different individual frequencies.7 While a full Fourier transform is computationally intensive for real-time rendering, this vectorial model provides a simple and powerful predictive algorithm for determining Moiré properties from the input parameters.


The Digital Rendering Approach: Moiré as Spatial Aliasing


In the context of digital graphics, Moiré patterns are a direct manifestation of a signal processing phenomenon called aliasing.9 Aliasing occurs when a signal is sampled at a rate lower than the Nyquist rate—that is, less than twice its highest frequency component.13 In digital imaging, the "signal" is the continuous geometric pattern being viewed, and the "sampling" is performed by the discrete grid of pixels on a camera sensor or a computer display.12
When a high-frequency repetitive pattern (like the fine weave of a fabric, a dense brick wall, or a computer-generated grating) is displayed on a screen, the grid of pixels may be too coarse to capture all the detail. This undersampling causes the high-frequency information to be misinterpreted as spurious, low-frequency patterns that were not present in the original scene. This artifact is the Moiré pattern.36
This understanding is critical for a web application because the appearance of a Moiré pattern generated by brute-force superposition (i.e., drawing two dense patterns on top of each other) can be highly dependent on the user's screen resolution and the scaling of the image.12 This can lead to unpredictable and inconsistent results. Several techniques, common in computer graphics, can be employed to mitigate or control these aliasing effects:
* Anti-Aliasing Filters: These filters work by intentionally blurring an image slightly before it is sampled by the pixel grid. This removes the highest frequencies that would otherwise cause aliasing. In digital cameras, this is often an optical low-pass filter (OLPF).12 In graphics programming, this can be achieved through techniques like multisample anti-aliasing (MSAA) or by applying a custom blur filter in a shader.
* Mipmapping: A standard technique in 3D graphics where pre-calculated, lower-resolution versions of a texture are used when the texture is viewed from a distance. By using a properly filtered, lower-resolution texture, high-frequency aliasing artifacts are avoided.13
* Procedural Bypass: As discussed in the algebraic section, the most effective way to avoid digital aliasing artifacts is to not render the high-frequency source patterns at all. Instead, one can use the indicial equations to calculate and draw the Moiré fringes directly, ensuring a clean and predictable result regardless of screen resolution.
These three mathematical frameworks are not mutually exclusive; they represent a spectrum of algorithmic strategies. The indicial method offers a direct, performant rendering algorithm for clean vector output. The Fourier method provides an analytical model for predicting Moiré behavior. The aliasing approach simulates the physical phenomenon most faithfully but is computationally expensive and artifact-prone. A sophisticated Moiré generator application could offer different rendering modes based on these strategies, allowing the user to choose between clean vector generation and realistic, artifact-rich raster simulation.


From Theory to Practice: Building an Interactive Moiré Generator in React


Translating the rich theory of Moiré patterns into a fun and interactive web application requires a robust architectural plan, practical code implementations, and the right choice of libraries. This section provides a blueprint for building such an application using React and the p5.js creative coding library.


Architectural Blueprint: Integrating p5.js with React


The core challenge in building this application is bridging the gap between React's declarative DOM management and the imperative, immediate-mode drawing model of the HTML5 Canvas API, which p5.js simplifies.40 A clean separation of concerns is paramount.


The Component Structure


The recommended approach uses modern React Hooks, specifically useRef and useEffect, to encapsulate the p5.js sketch within a dedicated React component (e.g., <MoiréCanvas>).
1. Container Reference: A div element within the React component will serve as the container for the p5.js canvas. A reference to this div is created and maintained using the useRef hook. This provides a stable DOM node for p5.js to attach to.41
2. Sketch Instantiation: The p5.js sketch is instantiated within a useEffect hook. This ensures the sketch is created only after the component has mounted to the DOM. Crucially, p5.js should be used in "instance mode," where all p5 functions are called on a specific sketch instance (e.g., p.createCanvas() instead of createCanvas()). This prevents p5.js from polluting the global namespace and allows for multiple, independent sketches on the same page.41
3. Cleanup: The useEffect hook must return a cleanup function. This function will be executed when the component unmounts. Inside this function, p5Instance.remove() should be called. This is essential for preventing memory leaks and addresses a common issue where React's Strict Mode (which double-invokes effects in development) would otherwise create duplicate canvases.44


State Management and Props


All user-configurable parameters of the Moiré pattern—such as the type of primitives for each layer, their rotation, scale, color, and displacement—should be managed as state within the parent React component using useState. These state variables are then passed down to the <MoiréCanvas> component as props.
To ensure the p5.js sketch updates efficiently when these props change, a mechanism is needed to pass the new props into the running sketch without re-creating it entirely. Libraries like @p5-wrapper/react provide a built-in updateWithProps function within the sketch for this purpose.46 A manual implementation can also achieve this by leveraging the dependency array of a
useEffect hook that calls a custom update function on the p5 instance.


Recommended Libraries


* @p5-wrapper/react: This is a modern, well-maintained library that provides a clean, hook-based wrapper for integrating p5.js into React applications. It handles the boilerplate of instance management, prop updates, and cleanup, making it an excellent choice for this project.46 The older
react-p5 package is deprecated and should be avoided.47
* p5.js: The core creative coding library.40


The Moiré Engine: Algorithmic Recipes with p5.js Code


This section provides a set of p5.js functions that implement the Moiré patterns discussed in Part I. Each function is a self-contained recipe that can be integrated into the React/p5.js architecture.


Recipe 1: Rotated Line Gratings (Brute-Force Raster Method)


This recipe demonstrates the most direct simulation of the physical phenomenon, where two gratings are drawn and the Moiré pattern emerges through their visual interference. The user can control the rotation of the second layer.


JavaScript




// This function would be the core of a p5.js sketch instance.
// It expects to receive props from its React wrapper component.
function sketch(p) {
 let rotation = 0; // Will be controlled by React state via props.

 p.setup = () => {
   p.createCanvas(500, 500);
 };

 // This function is called by the wrapper when props change.
 p.updateWithProps = (props) => {
   if (props.rotation!== undefined) {
     // Convert degrees from slider to radians for p5.js
     rotation = p.radians(props.rotation);
   }
 };

 p.draw = () => {
   p.background(255); // White background
   const pitch = 20; // Spacing between lines

   // Draw Layer 1 (static) with a semi-transparent blue color
   drawGrating(p, pitch, 0, p.color(0, 0, 255, 150));

   // Draw Layer 2 (rotated) with a semi-transparent red color
   drawGrating(p, pitch, rotation, p.color(255, 0, 0, 150));
 };

 // Helper function to draw a grating of vertical lines
 function drawGrating(p, pitch, angle, strokeColor) {
   p.push(); // Save current drawing style and transformation
   p.translate(p.width / 2, p.height / 2); // Move origin to center
   p.rotate(angle); // Rotate the grid
   p.stroke(strokeColor);
   p.strokeWeight(2);
   // Draw lines to cover the canvas area
   for (let x = -p.width; x < p.width; x += pitch) {
     p.line(x, -p.height, x, p.height);
   }
   p.pop(); // Restore original drawing style and transformation
 }
}

This implementation is based on the principles described in 1 and uses a code structure adapted from examples in.48


Recipe 2: Lines on Circles (Direct Vector Method via Indicial Equation)


This recipe uses the algebraic method to draw the resulting Moiré fringes directly, avoiding the rendering of the base patterns. This is far more performant and produces clean, scalable output.


JavaScript




// p5.js sketch function using the indicial equation directly.
function sketch(p) {
 let a = 50; // Circle spacing factor, controlled by props
 let b = 40; // Line spacing factor, controlled by props

 p.setup = () => {
   p.createCanvas(500, 500);
 };

 p.updateWithProps = (props) => {
   if (props.circleSpacing) a = props.circleSpacing;
   if (props.lineSpacing) b = props.lineSpacing;
 };

 p.draw = () => {
   p.background(255);
   p.stroke(0);
   p.noFill();
   p.strokeWeight(1.5);

   // From [14] and [14], the Moiré equation is a quadratic in x.
   // (b^2 - a^2)x^2 + (2a^2bp)x + (b^2y^2 - a^2b^2p^2) = 0
   // We can plot this for several integer values of the Moiré index 'p'.
   const p_max = 15;
   for (let p = -p_max; p <= p_max; p++) {
     if (p === 0) continue; // Avoid division by zero issues
     
     p.beginShape();
     // Iterate through y-values to plot the curve
     for (let y = -p.height / 2; y < p.height / 2; y += 2) {
       const A = p.sq(b) - p.sq(a);
       const B = 2 * p.sq(a) * b * p;
       const C = p.sq(b) * p.sq(y) - p.sq(a * b * p);

       // Solve the quadratic equation Ax^2 + Bx + C = 0 for x
       const discriminant = p.sq(B) - 4 * A * C;
       if (discriminant >= 0) {
         const x1 = (-B + p.sqrt(discriminant)) / (2 * A);
         // For simplicity, we plot one root. A full implementation would handle both.
         p.vertex(x1 + p.width / 2, y + p.height / 2);
       }
     }
     p.endShape();
   }
 };
}



Recipe 3: Kinegram Animation


This recipe outlines the logic for creating a barrier-grid animation. It requires two components: a function to generate the composite image and a function to draw the moving barrier.


JavaScript




// Logic for creating a 4-frame kinegram
let frames =; // Array of 4 p5.Image objects, loaded in preload()
let compositeImage;
let barrier;
let barrierX = 0;

function setup() {
 createCanvas(400, 400);
 // Assume 'frames' are loaded
 
 // 1. Create the composite image
 compositeImage = createGraphics(width, height);
 const stripeWidth = 1; // Width of each image slice
 const numFrames = 4;
 
 for (let x = 0; x < width; x += stripeWidth) {
   const frameIndex = (x / stripeWidth) % numFrames;
   // Copy a vertical stripe from the corresponding frame to the composite image
   compositeImage.copy(frames[frameIndex], x, 0, stripeWidth, height, x, 0, stripeWidth, height);
 }
 
 // 2. Create the barrier grid
 barrier = createGraphics(width, height);
 barrier.background(0, 0); // Transparent background
 barrier.fill(0); // Black opaque lines
 barrier.noStroke();
 const opaqueWidth = stripeWidth * (numFrames - 1); // 3 pixels opaque
 const totalPitch = stripeWidth + opaqueWidth; // 4 pixels total
 
 for (let x = 0; x < width; x += totalPitch) {
   barrier.rect(x, 0, opaqueWidth, height);
 }
}

function draw() {
 background(255);
 image(compositeImage, 0, 0);
 
 // Draw the moving barrier
 image(barrier, barrierX, 0);
 
 // Animate the barrier
 barrierX = (barrierX + 1) % (width);
}

This algorithm is a direct implementation of the principles described in.29


High-Performance Rendering with WebGL Shaders


For maximum interactivity and the ability to handle extremely dense patterns without performance degradation, rendering should be offloaded from the CPU to the GPU using WebGL. The p5.js createCanvas() function accepts WEBGL as an argument to enable this mode.46 The logic for pattern generation is then written in a
fragment shader using the GLSL language. A fragment shader is a program that runs for every pixel of the canvas, making it exceptionally efficient for procedural generation.
The following GLSL code generates a Moiré pattern from two slightly different rotated line gratings. This code would be passed as a string to a p5.Shader object in the p5.js sketch.


OpenGL Shading Language




// File: moire.frag
precision mediump float;

// Uniforms are variables passed from the p5.js sketch to the shader
uniform vec2 u_resolution; // The canvas resolution
uniform float u_time;      // A time variable for animation
uniform float u_pitch1;    // Pitch of the first grating
uniform float u_pitch2;    // Pitch of the second grating
uniform float u_angle;     // Relative angle of rotation

// Function to draw a pattern of parallel lines
float linePattern(vec2 uv, float frequency) {
 // Use a sine wave to create smooth lines
 return sin(uv.x * frequency) * 0.5 + 0.5;
}

void main() {
 // Normalize fragment coordinates to a  range
 vec2 uv = gl_FragCoord.xy / u_resolution.xy;

 // Layer 1: A static set of lines
 float layer1 = linePattern(uv, u_pitch1);

 // Layer 2: A rotated set of lines
 float angle = u_angle;
 mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
 vec2 rotated_uv = rotationMatrix * (uv - 0.5) + 0.5; // Rotate around the center
 float layer2 = linePattern(rotated_uv, u_pitch2);

 // Superposition: Multiply the layers to combine them.
 // Where both are bright (1.0), the result is bright. Otherwise, it's dark.
 float final_color = layer1 * layer2;

 // Output the final color for the current pixel
 gl_FragColor = vec4(vec3(final_color), 1.0);
}

This shader-based approach is inspired by the techniques common in the Shadertoy community and offers the highest level of performance for a real-time interactive application.51


Capturing the Moment: Exporting Images and Animations


A key feature of a creative tool is the ability to export the work. The application should support exporting both static images and animated GIFs.


Static Image Export


Two primary methods exist for capturing the canvas as a static image:
   1. p5.saveCanvas(): This is the simplest method, built directly into p5.js. It saves the current content of the p5 canvas to a file (e.g., PNG or JPG). This is ideal for exporting just the artwork itself.
   2. html2canvas: This JavaScript library can capture a "screenshot" of a specified DOM element, or even the entire page.53 This is the superior method if the user wishes to capture not only the Moiré pattern but also the application's UI controls in the same image. The library renders the DOM content to a new canvas element, which can then be converted to a data URL and downloaded.55


Animated GIF Export


Creating animated GIFs on the client-side requires a JavaScript library capable of encoding a sequence of canvas frames. gif.js is a popular choice for this task.57 The workflow is as follows:
   1. Initiate Recording: When the user clicks a "Record" button, a new GIF encoder instance is created.
   2. Frame Capture: Inside the p5.js draw() loop, which executes for every frame of the animation, the current state of the canvas is captured and added to the encoder using gif.addFrame(canvasElement, {copy: true, delay: 40}). The delay option specifies the time between frames in milliseconds.57
   3. Finalize and Download: When the user clicks "Stop," the gif.render() method is called. This begins the encoding process, which runs in a web worker to avoid freezing the UI. Upon completion, the library fires a finished event, providing the final GIF as a blob. This blob can be converted to an object URL and attached to an anchor tag to trigger a download.57
The architectural separation of state (React) from rendering (p5.js) is crucial. It allows for future enhancements, such as swapping the rendering backend (e.g., to a dedicated SVG renderer like p5.js-svg for vector exports 59) or using different export libraries, without needing to restructure the entire application.


Conclusion: Creative and Scientific Horizons


The study of Moiré patterns sits at a fascinating intersection of mathematics, physics, computer science, and art. From its origins in textile design to its cutting-edge applications in quantum materials, the Moiré effect is a testament to how complex and beautiful phenomena can emerge from simple, underlying rules. For the creative developer, this provides a vast and fertile territory for exploration.


A Gallery of Inspiration


The potential of a Moiré generation tool is best understood by looking at how these patterns have been used by artists and scientists:
   * In Art: The Op Art movement of the 20th century heavily utilized principles of interference and perception. Bridget Riley's painting "Fall" (1963) uses undulating lines to create a powerful sense of movement and visual vibration, a macroscopic effect akin to Moiré.60 The kinetic sculptures of Ludwig Wilding directly employ Moiré by layering grids of lines on plexiglass to create dynamic, three-dimensional illusions that shift with the viewer's position.61
   * In Science and Design: Dr. Gerald Oster, a biophysicist, was instrumental in popularizing the scientific study and application of Moiré patterns in the 1960s. His articles and collaboration with Edmund Scientific on Moiré kits introduced the phenomena to a wider audience, showcasing patterns like the "Spider" (from rotated radial lines) and those based on logarithmic spirals.60 Today, Moiré techniques are used for high-precision strain and stress analysis in materials engineering 5 and are at the heart of "twistronics," where Moiré superlattices in 2D materials like graphene unlock novel quantum properties.21
   * In Generative Art: Modern creative coding communities on platforms like OpenProcessing, Dwitter, and Shadertoy continually explore the aesthetic possibilities of Moiré.6 Artists use code to generate dynamic and interactive patterns, often combining them with other generative techniques like Perlin noise or reacting them to sound.6


Actionable Recommendations for Development


This report has laid out a comprehensive roadmap for creating a powerful and engaging Moiré pattern generator. The key takeaways for development are:
   1. Structure the App Around the Taxonomy: The classification of Moiré patterns (Linear/Curvilinear, Lattices, Animated) provides a natural structure for the application's user interface and feature set. Start with the simplest primitives and progressively introduce more complex options.
   2. Employ a Multi-Strategy Algorithmic Core: Do not rely on a single method for generation. The application should be architected to support multiple rendering strategies. The Indicial Equation method is ideal for a fast, clean "Vector Mode." The brute-force superposition method is perfect for a "Realistic/Raster Mode" that simulates digital aliasing. The Fourier model should inform the logic of the user controls.
   3. Build on a Modern React + p5.js Architecture: Use a robust wrapper like @p5-wrapper/react and adhere to best practices for React Hooks (useRef, useEffect) and component lifecycle management. This ensures a clean separation of concerns, prevents common bugs like memory leaks, and creates a scalable foundation.


Future Directions


The framework presented here is a starting point. The application can be extended in numerous exciting directions:
   * Sound Reactivity: Implement audio input to control Moiré parameters, creating dynamic audio-visualizers.6
   * Three-Dimensional Moiré: Extend the concepts into 3D space, exploring patterns that emerge from the superposition of 3D grids or volumetric textures that change with the virtual camera's perspective.4
   * Exotic Geometries: Move beyond Euclidean primitives to generate Moiré from non-periodic or quasi-periodic patterns, such as Penrose tilings or space-filling curves, which produce their own unique and complex interference patterns.26
By combining a deep understanding of the mathematics with a practical approach to software architecture, it is possible to build an application that is not only a fun and engaging creative tool but also an educational platform for exploring the profound and beautiful principles of interference.
Works cited
   1. Moiré pattern - Wikipedia, accessed July 1, 2025, https://en.wikipedia.org/wiki/Moir%C3%A9_pattern
   2. www.researchgate.net, accessed July 1, 2025, https://www.researchgate.net/figure/Two-types-of-superposition-The-two-gratings-in-a-and-b-are-multiplied-in-c-and_fig1_11945071#:~:text=Generally%2C%20the%20superposition%20of%20two,fringe%20%5B2%2C3%5D.
   3. www.exploratorium.edu, accessed July 1, 2025, https://www.exploratorium.edu/snacks/moire-patterns#:~:text=When%20two%20identical%20repetitive%20patterns,image%20formed%20in%20your%20eye.
   4. Moiré Patterns - WeWantToLearn.net, accessed July 1, 2025, https://wewanttolearn.wordpress.com/2015/10/07/moire-patterns/
   5. Moiré Method - University of Washington, accessed July 1, 2025, https://depts.washington.edu/mictech/optics/me557/moire_a.pdf
   6. The Overlapping Beauty of Moiré Patterns - barbe_generative_diary, accessed July 1, 2025, https://barbegenerativediary.com/en/tutorials/moire-pattern-the-overlapping-beauty-of-moire-patterns/
   7. Moiré: Formation and interpretation - Optics Letters, accessed July 1, 2025, https://opg.optica.org/fulltext.cfm?uri=josa-64-10-1287
   8. A Fourier-series Approach to Moiré Patterns with Special Reference ..., accessed July 1, 2025, https://www.tandfonline.com/doi/pdf/10.1080/713819066
   9. Moire – Knowledge and References - Taylor & Francis, accessed July 1, 2025, https://taylorandfrancis.com/knowledge/Engineering_and_technology/Engineering_support_and_special_topics/Moire/
   10. Moire Patterns: Perception & Light Science Activity | Exploratorium Teacher Institute Project, accessed July 1, 2025, https://www.exploratorium.edu/snacks/moire-patterns
   11. Moiré Patterns - YouTube, accessed July 1, 2025, https://www.youtube.com/watch?v=H9G9pNFVUfg
   12. Understanding aliasing and anti-aliasing techniques in photography. - Adobe, accessed July 1, 2025, https://www.adobe.com/creativecloud/photography/discover/anti-aliasing.html
   13. Aliasing and Moire patterns - Rick Matthews, accessed July 1, 2025, https://matthews.sites.wfu.edu/misc/DigPhotog/alias/
   14. Theoretical Interpretation of Moiré Patterns - Optics Letters - Optica, accessed July 1, 2025, https://opg.optica.org/abstract.cfm?uri=josa-54-2-169
   15. Moiré Patterns - Scaling Circles and Lines - YouTube, accessed July 1, 2025, https://www.youtube.com/watch?v=mzPIWHDwBFo
   16. Marcin Brzezicki Paper: Designer's controlled and randomly generated moiré patterns in architecture., accessed July 1, 2025, http://generativeart.com/GA2011/marcin.pdf
   17. The Geometry of the Moiré Effect in One, Two, and Three Dimensions - Cambridge Scholars Publishing, accessed July 1, 2025, https://www.cambridgescholars.com/resources/pdfs/978-1-5275-8405-1-sample.pdf
   18. Light and Color - Moire Patterns: Interactive Tutorial - Molecular Expressions, accessed July 1, 2025, https://micro.magnet.fsu.edu/primer/java/scienceopticsu/moirepatterns/index.html
   19. Spectral Analysis and Minimization of Moiré Patterns in Colour Separation - CNRS, accessed July 1, 2025, https://perso.liris.cnrs.fr/ostrom/publications/pdf/JEI94_Moire.pdf
   20. Fast numerical Fourier analysis of moiré pattern induced by a periodic metallic array on top of the microscopically patterned red-green-blue light sources - Optics Letters, accessed July 1, 2025, https://opg.optica.org/abstract.cfm?uri=ao-57-27-8044
   21. The Mathematics and Physics of Moiré Superlattices, accessed July 1, 2025, https://www.birs.ca/workshops/2023/23w5058/report23w5058.pdf
   22. Moiré physics in twisted van der Waals heterostructures of 2D materials, accessed July 1, 2025, https://einstein.nju.edu.cn/upload/uploadify/20230214/2021-em-Moir%C3%A9physicsintwistedvanderWaalsheterostructuresof2Dmaterials_202302141813266470.pdf
   23. Moiré Patterns Reveal Materials' Hidden Properties - AIP.ORG, accessed July 1, 2025, https://www.aip.org/inside-science/moire-patterns-reveal-materials-hidden-properties
   24. Moire pattern of 2D materials - Clean Energy Institute, accessed July 1, 2025, https://www.cei.washington.edu/wp-content/uploads/2020/06/Moire-pattern-of-2D-Materials.pdf
   25. Colloquium Apr 11, 2019 -- Moiré Patterns in Two-Dimensional Materials - YouTube, accessed July 1, 2025, https://www.youtube.com/watch?v=4ZP86d_5Rg4
   26. Objective Moiré Patterns | J. Appl. Mech. | ASME Digital Collection, accessed July 1, 2025, https://asmedigitalcollection.asme.org/appliedmechanics/article/92/8/081002/1212941/Objective-Moire-Patterns
   27. (PDF) Objective Moiré Pattern - ResearchGate, accessed July 1, 2025, https://www.researchgate.net/publication/385823815_Objective_Moire_Pattern
   28. [2411.09438] Objective Moiré Pattern - arXiv, accessed July 1, 2025, https://arxiv.org/abs/2411.09438
   29. 2D Moire (Slit) Animation : 7 Steps (with Pictures) - Instructables, accessed July 1, 2025, https://www.instructables.com/2D-Moire-Slit-Animation/
   30. Moire Patterns - Evident Scientific, accessed July 1, 2025, https://evidentscientific.com/en/microscope-resource/tutorials/moire
   31. Circular Moiré Slit Animation : 4 Steps (with Pictures) - Instructables, accessed July 1, 2025, https://www.instructables.com/Circular-Moir%C3%A9-Slit-Animation/
   32. Application of moire analysis of strain using Fourier transform - SPIE Digital Library, accessed July 1, 2025, https://www.spiedigitallibrary.org/journals/optical-engineering/volume-27/issue-8/278650/Application-Of-Moire-Analysis-Of-Strain-Using-Fourier-Transform/10.1117/12.7976737.pdf
   33. That's a Moiré - Chalkdust Magazine, accessed July 1, 2025, https://chalkdustmagazine.com/features/thats-a-moire/
   34. QC series – Aliasing and Moiré: Navigating quality challenges in film and TV - Pomfort, accessed July 1, 2025, https://pomfort.com/article/qc-series-aliasing/
   35. Aliasing and Moiré. What is it and what can be done about it? - XDCAM-USER.com, accessed July 1, 2025, https://www.xdcam-user.com/everything-else/old-stuff/aliasing-and-moire-what-is-it-and-what-can-be-done-about-it/
   36. Understanding Moiré in Photography and How to Avoid It, accessed July 1, 2025, https://proedu.com/blogs/photography-fundamentals/understanding-moire-in-photography-and-how-to-avoid-it
   37. Understanding Moire Pattern - NMR Events, accessed July 1, 2025, https://www.nmrevents.com/post/understanding-moire-pattern
   38. Why does this Moiré pattern look this way? - MathOverflow, accessed July 1, 2025, https://mathoverflow.net/questions/264711/why-does-this-moir%C3%A9-pattern-look-this-way
   39. Moiré pattern : r/math - Reddit, accessed July 1, 2025, https://www.reddit.com/r/math/comments/41kgud/moir%C3%A9_pattern/
   40. p5.js, accessed July 1, 2025, https://p5js.org/
   41. Integrating P5.js with React - DEV Community, accessed July 1, 2025, https://dev.to/christiankastner/integrating-p5-js-with-react-i0d
   42. Creating a Custom D3 or P5 Hook in React - DEV Community, accessed July 1, 2025, https://dev.to/christiankastner/creating-a-custom-d3-or-p5-hook-in-react-fap
   43. How to use React with p5.js - Stack Overflow, accessed July 1, 2025, https://stackoverflow.com/questions/54868777/how-to-use-react-with-p5-js
   44. How to Prevent a Duplicated Canvas When Using P5 and React Strict Mode, accessed July 1, 2025, https://www.lloydatkinson.net/posts/2022/how-to-prevent-a-duplicated-canvas-when-using-p5-and-react-strict-mode/
   45. p5.js and React: how to update a sketch inside a component when one of the component's props is updated - Stack Overflow, accessed July 1, 2025, https://stackoverflow.com/questions/69548835/p5-js-and-react-how-to-update-a-sketch-inside-a-component-when-one-of-the-compo
   46. P5-wrapper/react: A wrapper component that allows you to utilise P5 sketches within React apps. - GitHub, accessed July 1, 2025, https://github.com/P5-wrapper/react
   47. react-p5 - NPM, accessed July 1, 2025, https://www.npmjs.com/package/react-p5
   48. moire patterns? - p5.js Web Editor, accessed July 1, 2025, https://editor.p5js.org/cassie/sketches/Vl7grLcFW
   49. Integrating p5.js with React - DEV Community, accessed July 1, 2025, https://dev.to/gssudharsan/integrating-p5-js-with-react-3g5e
   50. Integrating p5.js and WebGL With React.js | by Ariki - Medium, accessed July 1, 2025, https://medium.com/@edoueda/integrating-p5-js-and-webgl-with-react-js-96c848a63170
   51. Special Shadertoy features, accessed July 1, 2025, https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/
   52. Reducing moiré patterns in a simple fragment shader? : r/GraphicsProgramming - Reddit, accessed July 1, 2025, https://www.reddit.com/r/GraphicsProgramming/comments/1bg2kgr/reducing_moir%C3%A9_patterns_in_a_simple_fragment/
   53. Getting Started | html2canvas, accessed July 1, 2025, https://html2canvas.hertzen.com/getting-started
   54. html2canvas - Screenshots with JavaScript, accessed July 1, 2025, https://html2canvas.hertzen.com/
   55. Using html2canvas - Don't Panic Labs, accessed July 1, 2025, https://dontpaniclabs.com/blog/post/2023/08/31/using-html2canvas/
   56. Moiré Patterns | Wolfram Demonstrations Project, accessed July 1, 2025, https://demonstrations.wolfram.com/MoirePatterns/
   57. gif.js, accessed July 1, 2025, https://jnordberg.github.io/gif.js/
   58. Canvas to GIF / Mike Bostock - Observable, accessed July 1, 2025, https://observablehq.com/@mbostock/canvas-to-gif
   59. How to use p5 SVG in a web app with React frontend and an Express backend, accessed July 1, 2025, https://stackoverflow.com/questions/75704314/how-to-use-p5-svg-in-a-web-app-with-react-frontend-and-an-express-backend
   60. A Moire Story - HeroComm, accessed July 1, 2025, http://www.herocomm.com/Details/MoireStory.htm
   61. The Moiré Museum - SQRT.CH, accessed July 1, 2025, https://www.sqrt.ch/museum
   62. Film Moiré - Algorithmic Pattern - PubPub, accessed July 1, 2025, https://alpaca.pubpub.org/pub/ni3sodf3
   63. Moiré Pattern Art | Horizontal lines with noise (Creative coding, Processing generative art), accessed July 1, 2025, https://www.youtube.com/watch?v=oiIxQ_JxbZo