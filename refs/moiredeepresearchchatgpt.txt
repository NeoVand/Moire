# Moiré Patterns: Theory, Types, and Techniques for Generative Design

**Moiré patterns** are large-scale interference patterns produced by overlaying two similar sets of lines or shapes with a slight offset, rotation, or size difference. In essence, when one semi-transparent repetitive pattern lies atop another, their misalignment creates a new, emergent pattern of broad alternating bands or shapes that were not present in either original layer. This phenomenon appears in various fields – from physics and optics (as an analog to wave interference and beats) to everyday imaging (like the unwanted moiré artifacts in photography/printing) – but it can also be harnessed artistically. In fact, moiré patterns are *particularly suitable for visualization as procedurally generated art*, capable of producing fascinating optical illusions. Below, we delve into the mathematics behind moiré patterns, survey the major classes of 2D moiré patterns (with famous examples), and discuss practical techniques (in WebGL/Canvas and more) for generating these patterns in an interactive app.

## Mathematical Basis of Moiré Interference

At its core, a moiré pattern arises from the **nonlinear superposition** of two periodic structures. When two sets of lines or grids are overlaid with a slight difference in spacing (frequency) or orientation, the eye perceives a new lower-frequency pattern – analogous to a *beat frequency* in acoustics. For example, consider two parallel line gratings: if the first has line spacing (period) *p* and the second *p′ = p + Δp*, broad dark and light bands will appear with a spacing (moire period) much larger than *p*. In fact, the moiré “fringe” spacing in one dimension can be calculated as:

$p_{\text{moire}} \approx \frac{p \cdot p'}{|p - p'|}~,$

which for small Δp is very large. This illustrates **moiré magnification**: tiny differences in pattern pitch yield an amplified distance in the moiré pattern. In practical terms: *the closer the two pattern frequencies (or the smaller the angle difference), the larger and more widely spaced the moiré bands*. Conversely, a bigger mismatch produces finer, more closely spaced moiré fringes. This magnification effect is so striking that engineers use moiré patterns in measurement devices (e.g. superposed gratings in micrometers) to detect minute displacements by the large movement of moiré bands.

When patterns are rotated relative to each other, similar principles apply. Two identical transparent line grids rotated by a small angle *α* will produce moiré bands oriented at roughly *α/2* to the original lines (the exact geometry can be derived via the difference of their spatial frequencies as vectors). The pattern will *vary with the angle* – a 0° rotation yields perfect overlap (no moiré), while a few degrees can produce prominent diagonal stripes. As *α* increases, the moiré stripes become finer and eventually disappear into a busy crosshatch when the grids are very misaligned (e.g. 45°). In summary, moiré formation requires that the two overlaid patterns are not identical but **shifted, rotated, or scaled** relative to one another; this slight misalignment causes a *distinct third pattern* to emerge, one not present in either layer alone.

## Types of 2D Moiré Patterns and Notable Examples

Moiré patterns come in many flavors depending on the shapes and transformations of the two layers. Here we outline the major classes of 2D moiré patterns – each with famous examples – that could be generated in an interactive app:

* **Line Moiré (Grating Moiré):** This is the classic case of overlapping **parallel lines or grids**. When two sets of straight, equidistant lines are superimposed with a small rotation or a slight difference in spacing, the result is a pattern of broad **dark and light bands** running across the overlap. These bands are essentially regions where lines from both layers either align (producing a thicker line or a combined dark region) or oppose (filling in each other’s gaps, producing a lighter region). **Rotated gratings** in particular produce striking stripe moirés – for example, overlaying two identical line screens with one rotated 5° yields large diagonal bands (as seen in many textbook images). You can observe this by holding two combs or mesh screens and viewing the interference bands that move as you change the angle. Another everyday example is looking through one chain-link fence at another – a fine mesh viewed through an identical mesh can reveal a magnified moiré pattern at a distance. In digital graphics, line moiré often appears as an **aliasing artifact**: e.g. photographing a striped shirt or a screen sometimes yields a moiré pattern because the camera’s pixel grid undersamples the fine pattern.

  &#x20;*Moiré pattern produced by two sets of parallel lines (one layer rotated a few degrees relative to the other). Broad horizontal “fringes” emerge as dark and light bands where the black lines either overlap or interlace. In a physical overlay, these correspond to regions of constructive vs. destructive overlap of the opaque lines.*

  In an interactive setting, **line moiré** patterns are easy to generate and fun to play with: by moving one layer of lines horizontally/vertically or rotating it slightly, the moiré bands will slide and change spacing. A small relative motion yields a much faster motion of the moiré bands – an effect known as *optical moiré speedup* (used in devices to amplify motion). This class also extends to **grids** (perpendicular sets of lines). Overlapping two grids can produce a larger checkerboard or lattice moiré. For instance, two square grids rotated a few degrees often show a **diamond mesh** moiré pattern at the angle bisector. Similarly, hexagonal or other lattice overlays can yield complex moiré superlattices. (In fact, in materials science, stacking 2D crystal lattices at a “magic” twist angle creates long-range moiré superlattices with exotic properties – a testament to how fundamental this effect is.)

* **Shape Moiré (Moiré Magnifier):** In a shape moiré, one layer contains a **repeating motif or shape**, and the other layer is typically a set of fine **revealing lines (stripes)**. The overlap causes enlarged versions of the motif to appear optically. This is because the thin lines pick out one part of the pattern at a time, effectively sampling the base pattern and creating a magnified composite image. In technical terms, *shape moiré* (also called **band moiré**) demonstrates moiré magnification: the composite reveals the base-layer shapes stretched and repeated. For instance, if you have a base layer with a tiny letter or symbol repeated in a grid, and a top layer of transparent stripes, the letters can suddenly become visible at a much larger scale in the moiré – a kind of optical "zoom". The math behind this was given earlier: if the stripe spacing (p\_r) is close to the shape repeat spacing (p\_b), the apparent moiré period p\_m = –(p\_b · p\_r)/(p\_b – p\_r) is large, meaning the tiny shape is blown up by a factor ≈ p\_m/p\_b. The **orientation and movement** of the magnified shape is also interesting: if you slide the stripe layer, the moiré shapes move much faster (by a factor of p\_b/(p\_b–p\_r) from the formula) and can even move opposite to the layer motion depending on which layer has finer spacing.

  A common example of shape moiré is the **chain-link fence illusion** mentioned earlier – the distant fence’s pattern is too fine to see with the naked eye, but looking through a second fence, you perceive a larger mesh pattern, effectively seeing the fine structure magnified. Shape moirés have been used in **hidden-image puzzles and security printing**: one layer encodes a compressed image in repetitive bands, and a overlay of stripes at the right spacing “decodes” it into a readable image. Artists have even created animations using a striped overlay dragged across a static image (a technique related to shape moiré) to make the picture appear to move frame by frame. In your moiré app, enabling a *shape moiré mode* – where the user can choose a base shape (text, icon, etc.) tiled in one layer and a stripe grid in the other – would allow creation of these magnified illusions. The user could adjust stripe spacing to control the magnification and inversion of the revealed shape (per the formula, if the stripe period is slightly larger than the shape’s period, the revealed image appears normal but moves reverse, whereas if stripe period is smaller, the image inverts vertically).

* **Circular and Radial Moiré:** Overlapping **concentric circle** patterns or other radial designs can produce striking moiré effects that often look like spirals or rotating waves. A famous example is two sets of concentric circles (ring patterns) that are slightly offset in radius or center. The moiré can appear as a series of **concentric beats** or even a spiral if one set is shifted laterally relative to the other. If one circle pattern is rotated relative to another (which effectively is a small azimuthal offset of the rings), you might see twisting lace-like fringes. The Wikipedia image of *“two sets of concentric circles”* shows a moiré pattern of radial bands. Another scenario is using **radial spoke patterns** (“spikes”). If you overlay two starburst patterns (like many radial lines emanating from a center), a slight rotation or offset can create a **kaleidoscopic moiré** where the spokes interfere to form moving rings or moiré “spokes” at a different angle.

  &#x20;*Moiré from overlapping circular patterns. Here two concentric-circle layers produce an interference pattern – note the broad horizontal band and gradient across the circle, an example of moiré magnification in a radial sense (the fine rings are undersampled in the middle vs edges). Such patterns can look like ripples or a target with alternating intensity regions.*

  **Spiral moirés** and **rotation-induced illusions** also fall in this category. For instance, the Exploratorium’s *“Spiral Moiré”* demo shows two spiral patterns moving against each other to produce pulsating movement. Artists like Takahiro Kurashima (in *Moirémotion*) use overlapping geometric patterns (circles, radial grids, zig-zags) that, when you slide a transparent film, create **spinning or vibrating illusions**. Many viewers experience a sense of motion or depth from these radial moirés. In an interactive app, one could include preset patterns like concentric rings or spiral grids; by dragging one pattern, the user sees dynamic moiré rings that appear to rotate or undulate. This can be especially **mind-bending** when animated – e.g. two circular gratings continuously rotating in opposite directions create a throbbing pattern that feels almost 3D.

* **Dot Moiré and Random Patterns:** Moiré patterns are not limited to regular lines or circles – even **random or pseudo-random arrangements** can yield fascinating effects. A prime example is the famous *“floating dot” illusion* popularized by mathematician Tadashi Tokieda (featured on Numberphile). Take two layers of randomly scattered dots (think of a star-field of points); when one layer is rotated just a few degrees relative to the other, the viewer sees an illusory shape like a **dark void or “hole” appear in a field of stars**. This happens because in some region the random dots from both layers coincidentally align and cancel out, creating a conspicuous gap, while elsewhere they create a dense overlap (the “hole” moves around as you adjust the alignment). In Tokieda’s demonstration, two identical random-dot transparencies slightly rotated produced a clear circular dark region – a striking moiré illusion that looks like a black hole opening up in noise.

  The interactive project *“Optical Illusions with Dots”* replicated this digitally: it generated a layer of thousands of random dots and a duplicate layer on top, allowing the user to rotate or translate the top layer by small increments. Small rotations (a few degrees) or tiny translations (a few pixels) are optimal – if you go too far, the pattern decorrelates and the illusion fades. With fine control, one can observe various **emergent patterns**: holes, clusters, or moiré ripples that arise from the interference of random distributions. Another well-known random-type moiré is when two layers of **perlin noise or textures** overlap – you might see swirling moiré interference of the noise grains. While not “regular”, these patterns highlight that moiré is fundamentally about **correlation** between two layers: even random arrangements will have regions of alignment and misalignment that the eye integrates into larger forms.

  Beyond dots, other shape combinations can produce moirés: e.g. a grid of small **squares or triangles** overlapped with a slightly rotated copy yields larger triangular or square moiré cells (as demonstrated in Numberphile as well). Essentially, any repeated 2D pattern overlapped with a similar pattern can produce a moiré – including hexagonal arrays (interesting for simulating graphene moiré patterns), parallel curves, text (letters over letters), etc. Your moiré app could offer a variety of base pattern types – random dots, regular polka-dots, checkerboards, geometric tilings – and let the user offset or rotate one layer to explore the resulting interference. Each yields a different “class” of moiré: for instance, offset dot grids create a rosette pattern; overlapping offset hexagonal lattices create a **super-hexagon moiré** (as studied in graphene bilayers); even two slightly different **quasicrystal patterns** overlapped might yield complex aperiodic moirés.

* **Color Moiré:** While most moiré patterns are discussed in black-and-white (opaque vs transparent), color can add another layer of richness or complexity. In printing, the term “moiré” often comes up with **CMYK halftone screens** – if the angle or frequency of the cyan, magenta, yellow dot grids are not well-chosen, they produce colored moiré ripples. In a creative context, one can overlay patterns of different colors to produce interference in the perceived color domain. For example, overlaying red and blue fine grids might produce a rippling pattern of purple vs red/blue where the grids overlap differently. However, in an interactive art app, pure color moiré is less common than monochrome because the eye’s perception of moiré relies mostly on luminance contrast. Still, it could be fun to let users assign different colors to the two layers for visual clarity (e.g. one layer blue, one layer red) – the overlaps then show as darker composite colors, which can help distinguish the layers or simply create a trippy effect.

## Techniques for Generating Moiré Patterns (Programming Focus)

Creating moiré patterns in a **web application** (e.g. a React-based app) can be achieved with modern web technologies while maintaining interactive performance. Key considerations are how to represent and draw the patterns efficiently, and how to apply transformations (move, rotate, scale) smoothly in real-time. Here we discuss some approaches and frameworks:

* **Canvas 2D Drawing:** The HTML5 Canvas API allows procedural drawing of shapes (lines, circles, etc.) in JavaScript/TypeScript. For moderate pattern sizes, this is straightforward: for example, to draw a line grating, one can loop to draw lines at regular intervals. To simulate two layers, you could either draw both on one canvas (first pattern, then second pattern with global alpha or composite), or use two stacked canvases. One simple method is to draw the base pattern on a canvas, then use another translucent canvas on top for the second pattern, which the user can translate/rotate via CSS transforms or canvas context transforms. By updating the transform each frame (or on user input), the moiré will update. However, drawing **very fine or large patterns** can be CPU-intensive if done pixel-by-pixel or shape-by-shape each frame. For instance, thousands of lines or dots may cause frame drops if redrawn continuously on the main thread.

* **WebGL / Shader approach:** Using WebGL (or its higher-level library like Three.js or regl) can leverage the GPU to generate and overlay patterns. One powerful technique is to use fragment **shaders** to proceduraly generate patterns. For example, a shader can implement a function for pattern1 (e.g. a sine wave or a stripe texture) and pattern2 (with a coordinate transform applied), then combine them by multiplying or adding. A simple case: represent each layer’s opacity as a binary or grayscale function \$f\_1(x,y)\$ and \$f\_2(x,y)\$ (1 for transparent/white, 0 for opaque/black, or values in between for antialiased edges). The **moire result** at each pixel could be approximated by the *minimum* or product of the two (since a pixel is white only if both layers are white at that position). In a shader, you could compute `float pattern = f1(u) * f2(u_transformed);` where `u_transformed` are coordinates adjusted by the user-controlled offset/rotation for layer2. This would directly produce the composite image. Using WebGL for this means the heavy computation is on the GPU and can handle high resolutions at 60 FPS, which is ideal for smooth animations (like continuously dragging a layer).

  Another WebGL approach is to treat each layer as a textured plane. You can pre-render a pattern to a texture (or generate it in a shader as well), then simply draw two quads with that texture, applying a rotation or offset to one. This is somewhat analogous to having two <canvas> or <div> layers and moving one, but entirely on the GPU. WebGL blending modes can combine the layers (for moiré, one would typically use multiply blending if treating white=1, black=0, so that overlapping black yields black). However, since moiré in physical terms is binary (opaque vs transparent), a pure multiply of intensities might result in grey levels unless thresholded. Many implementations just draw black lines on transparent background for each layer; when you overlay them, any area covered by a line from either layer appears black (union of black regions). The moiré bands then appear due to the **finite resolution** of the display (aliasing creates intermediate grays) or due to partial overlaps if using semi-transparent lines. This is worth noting: *aliasing is not always our enemy here – it can actually create smoother moiré illusions*. Techniques like drawing slightly thinner lines and relying on pixel averaging can make the moiré bands more visible as smooth shadows, rather than harsh binary patterns.

* **SVG or D3:** Another option is to use Scalable Vector Graphics for the patterns. Libraries like **D3.js** can dynamically generate SVG elements (lines, circles, etc.) and even handle some animations. One developer reports using D3 to create SVG patterns and then animating them with GSAP (GreenSock) for a moiré art project. SVG has the advantage of sharp rendering at any zoom and might be easier for vector shapes like circles or custom paths. However, animating a large number of SVG elements (like hundreds of lines or thousands of dots) can also become sluggish, since each element is a DOM node. If the patterns are moderate (say a grid of 50x50 shapes), SVG could work fine and benefits from easy rotation via grouping (e.g. put all shape elements in an `<svg> <g>` and rotate the `<g>`). For very fine patterns, Canvas or WebGL (which deal with pixels or shaders) are more performant.

* **External Libraries and Tools:** Given the interest in creative coding, there are many libraries and prior codes for moiré generation. For instance, **p5.js** (the JS cousin of Processing) has tutorials on making moiré patterns with a few lines of code (drawing a grid of lines and using the `difference` blend mode, etc.). A p5.js sketch can be embedded in a React app for quick prototyping. There are also specialized scripts – e.g. a Python Pillow script to generate moiré GIFs or a **Moire pattern kit** by I. Amidror (from his book) with PostScript files for printing transparencies. While those aren't directly for a webapp, they can provide algorithmic insight. Another interesting resource is **WolframAlpha/Mathematica**, which can visualize moiré of various lattice types – the math from there can be translated into shader formulas.

From a design standpoint, you indicated interest in **WebGL with TypeScript** – this is a great choice to ensure the app runs fluidly in-browser. You might use a library like *Three.js* (for easy scene setup) or go lower-level with raw WebGL or the newer WebGL2. With Three.js, for example, you could create two textured planes slightly in front of the camera. The texture could be generated from a small canvas or via a DataTexture. Three.js also lets you supply a custom shader material if you want to procedurally draw the pattern. On user input (mouse drag, sliders), you’d update the rotation or position of one plane (or adjust a uniform in the shader) to move the pattern and thus update the moiré. TypeScript will help catch errors as you manipulate these graphics APIs.

**Performance tips:** Moiré patterns can involve very high-frequency detail, which means lots of thin lines or tiny dots. To keep things smooth, consider these optimizations:

* **Offscreen precomputation:** If using Canvas2D, draw the base pattern once to an offscreen canvas or image. Then each frame, just blit it and transform for the second layer rather than redrawing everything. You can use `ctx.drawImage()` to draw the precomputed pattern with translation or even `ctx.rotate()` for rotation (though rotating a large image every frame might hit some performance limits, it’s usually OK for small angles and with GPU-accelerated canvas).

* **Level of detail / Resolution:** If the moiré patterns appear too fine to resolve on a typical screen (leading to flickering instead of a clean band pattern), you can slightly adjust thickness or use anti-aliasing. Conversely, if you want *really crisp moiré*, you may render at a higher resolution offscreen and scale down (or use the browser’s devicePixelRatio on Canvas to get more resolution). Techniques from game graphics like mipmapping and anisotropic filtering were literally invented to reduce unwanted moiré, but here we *want* the effect. So you might allow the user to toggle resolution or line thickness to see stronger or weaker moiré.

* **Procedural math vs. drawing**: As noted, a shader can use mathematical functions (like sinusoidal intensity patterns) to represent a layer. This can produce a smooth moiré without explicitly drawing discrete lines (the interference comes out of the math as a beat frequency). For example, combining two sinusoid gratings \$f\_1(x) = \sin(k\_1 x)\$ and \$f\_2(x) = \sin(k\_2 x)\$ by averaging will analytically produce a product of sines that equals a low-frequency cosinusoidal envelope. In practice, you could implement \$I(x) = 0.5\*(1+\sin(k\_1 x)) \* 0.5\*(1+\sin(k\_2 x))\$ in a fragment shader and get a smooth grayscale moiré pattern (no explicit lines, just brightness). This is a more mathematical approach and might be overkill unless you want continuous-tone moiré images. But it’s worth mentioning as it connects back to the theory – essentially you’re simulating wave interference, and the moiré is literally the beat.

## Designing an Interactive Moiré Pattern App

With the theory and techniques in mind, you can outline the features of a **“moire playground”** web app to make it fun and educational:

* **Pattern Selection:** Provide a menu of base patterns – e.g. *Lines*, *Grid*, *Circles*, *Radial Spikes*, *Random Dots*, *Custom Shape*. Each would generate a layer accordingly. For example, if the user picks "Lines", generate a high-resolution canvas with vertical lines; if "Random Dots", scatter N points; if "Shape", ask for an input shape or use a preset (like a letter “A” repeated in rows). Having a variety encourages exploring “all kinds of 2D moiré patterns” as requested.

* **Layer Control:** Since moiré comes from two layers, the UI should allow the user to manipulate the **relative transform** of Layer 2 over Layer 1. This includes:

  * **Translation** in X and Y (e.g. click-and-drag the top layer or use sliders for fine control). As the user moves it, the moiré pattern should update in real time.
  * **Rotation** of the top layer (a slider from -180° to 180° or a knob UI). Small rotations are most interesting; perhaps constrain or snap to small ranges for fine control, because as noted, beyond certain angles the effect diminishes.
  * **Scaling** or size difference. This is an often-overlooked but rich control: slightly scaling one pattern relative to the other produces moiré that can be concentric or expanding. For instance, in the random dot “black hole” illusion, one layer being \~4% smaller than the other created a circular void pattern. You can offer a “second layer size” slider (e.g. 100% = identical, 96% = slightly smaller) – this effectively introduces a radial drift between layers and yields *radial moiré* patterns.
  * **Opacity or Blend Mode:** It might be useful to let the user adjust the opacity of the top layer or toggle how the composition is done (e.g. normal overlap vs multiply). For pure moiré effect, full opacity (opaque black lines) is true to theory, but sometimes reducing opacity can make the overlapping structure easier to see. Some applications even color the two layers differently (e.g. red lines and blue lines) to help the eye distinguish them – you could allow color selection per layer for creativity (the moiré will then appear in mixed colors where they overlap).

* **Animation and Export:** A truly engaging feature is to allow **animation** of moiré patterns. For example, a toggle to auto-rotate the top layer slowly, or oscillate it back and forth, will create hypnotic moving moiré visuals. The user might set an angular speed or a translation oscillation (like layer 2 continuously slides horizontally). This can produce living, “mindblowing” patterns from simple setups (e.g. two circles continuously shifting phase). Since you also want to allow exporting, consider enabling users to export a **snapshot image** (PNG/SVG) of the current pattern, and possibly a short animated GIF or video of an animation cycle. Exporting animations can be done by capturing frames (for a small gif) or by encoding a canvas stream, though that can be advanced – a simpler route is letting the user record their screen or using a library to generate GIFs from canvas frames.

* **Guidance and Presets:** Because moiré effects have sweet spots (e.g. “between -5° to 5° rotation” as the Numberphile example suggests), you might include some preset configurations or a bit of text guidance for each pattern type. For instance, if “Random Dots” is chosen, you could note: “Try a rotation of only a few degrees and small X/Y shifts for best effect.” Or even have a button for “Tokieda’s black hole” preset which sets rotation \~2° and slight scale difference, so the user immediately sees the black hole illusion. Presets for line moiré could include a 5° rotation demo, etc. This ensures the app is **both easy and fun** – novices can hit a preset to see a cool effect, while advanced users tweak parameters freely.

* **Use of Libraries:** Given your willingness to incorporate libraries for feature-rich design, you might consider:

  * **Greensock (GSAP)** for smooth tweening of animations (it can animate CSS transforms or canvas properties at high performance, useful for auto-play demos or user-set motion).
  * **React-Three-Fiber** if you go the WebGL route with React; it’s a React renderer for Three.js that could simplify integrating interactive controls with WebGL scenes declaratively.
  * **PixiJS or Canvas API** if sticking to 2D but want GPU-accelerated sprite movement (Pixi can treat your pattern as a sprite and move it on the GPU, good for translations; rotations might still involve some rasterization).
  * For generative patterns, libraries like D3 or P5 can be prototyped, but ultimately raw Canvas or GL will give more control and speed. Since you mentioned TypeScript, writing some utility functions to generate pattern data (e.g. an array of line coordinates or dot positions) in TS can be useful, which you then render via chosen method.

In summary, building a moiré pattern app involves combining **mathematical knowledge** (to produce the patterns and understand the effects of transformations) with **practical coding techniques** to render and animate these patterns efficiently. Fortunately, moiré patterns are inherently procedural, which lends itself to algorithmic generation. They also naturally create *“surprising results”* that can captivate users, even with simple inputs.

## Conclusion

Moiré patterns showcase how simple components (lines, grids, dots) can interact to form elaborate visual phenomena. We have explored the gamut from basic line-grating moirés to complex shape magnifiers and random-dot illusions. Each type offers unique optical effects that can be leveraged in an interactive React/WebGL application. By drawing on the mathematical relationships (e.g. how slight differences yield large patterns) and using efficient rendering strategies, you can create an app that lets users **play with moiré** in real time – sliding layers to conjure hypnotic moving bands, rotating shapes to spawn swirling interference, and exporting their creations as art or design elements. The key is to keep it practical and fun: provide immediate visual feedback and intuitive controls, so users can *see* the mathematical beauty of moiré without struggling with setup. As noted in one project, moiré patterns “can create some really interesting optical illusions” and are ideal for procedural art – your app can bring those illusions to anyone with a web browser. With WebGL and modern libraries, even complex moiré animations can run smoothly in-browser, making it possible to achieve the “mindblowing” patterns and interactive experience you envision. Happy coding, and enjoy the mesmerizing world of moiré!

**Sources:**

* Wikipedia: *Moiré pattern* – definition and characteristics
* Wikipedia: *Shape moiré* – magnification effect and examples
* Exploratorium – *Tinkering with Moiré Patterns* – artistic examples (Kurashima’s *Moirémotion* book)
* Chi-Loong Chan, *“A Study in Moiré Patterns”* – on using D3/Greensock for moiré visuals
* MyCarta Blog, *“Moiré Patterns”* – on rotating line gratings and aliasing effects
* *Numberphile/Tokieda dot illusion recap* – interactive dot moiré experiment and settings
* Amidror (EPFL) – *Moiré demonstration kit* (theory of moiré phenomenon)
* Moiré pattern derivations – showing formation of dark/light zones and dependence on pattern gap
